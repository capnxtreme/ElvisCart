// ElvisCart - Simple but fun rockabilly kart racer
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Game state
const game = {
    state: 'menu', // menu, racing, results
    frame: 0,
    totalLaps: 3,
    raceStarted: false,
    countdown: 3,
    raceFinished: false,
    finishOrder: []
};

// Player kart
const player = {
    x: 0,
    y: 0,
    position: 0,
    speed: 0,
    maxSpeed: 600,  // Doubled max speed!
    acceleration: 25,  // Faster acceleration
    steering: 0,
    drifting: false,
    driftAngle: 0,
    driftPower: 0,
    boostPower: 0,
    lateralVelocity: 0,
    lap: 0,
    checkpoint: 0,
    finished: false,
    finishTime: 0,
    powerUp: null,
    powerUpActive: null,
    powerUpTimer: 0,
    shielded: false,
    slipping: false,
    collisionTimer: 0
};

// Input handling
const keys = {};
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

// AI Opponents
const opponents = [];
const OPPONENT_NAMES = ['Betty Bombshell', 'Johnny Hot Rod', 'Buddy Bopper', 'Peggy Sue'];
const OPPONENT_COLORS = ['#FF1493', '#4169E1', '#32CD32', '#FFD700'];

// Initialize AI opponents
function initOpponents() {
    for (let i = 0; i < 4; i++) {
        opponents.push({
            name: OPPONENT_NAMES[i],
            color: OPPONENT_COLORS[i],
            x: (i - 1.5) * 300,  // Spread across starting line
            position: -i * 100,    // Behind starting line
            speed: 0,
            maxSpeed: 500 + Math.random() * 100,  // Varying skill levels
            steering: 0,
            targetX: 0,
            personality: Math.random(),  // Affects driving style
            boostPower: 0,
            lap: 0,
            checkpoint: 0,
            finished: false,
            finishTime: 0,
            powerUp: null,
            powerUpActive: null,
            powerUpTimer: 0,
            shielded: false,
            slipping: false,
            lateralVelocity: 0,
            collisionTimer: 0
        });
    }
}

// Track segments
const segments = [];
const segmentLength = 200;
const trackLength = 200; // Longer track
const trackWidth = 2000;

// Power-ups
const powerUps = [];
const POWERUP_TYPES = {
    pomadeSlick: { 
        name: 'Pomade Slick', 
        color: '#8B4513', 
        icon: 'ðŸ›¢ï¸',
        duration: 3
    },
    jukeboxBlast: { 
        name: 'Jukebox Blast', 
        color: '#FF1493', 
        icon: 'ðŸŽµ',
        radius: 300
    },
    chromeLightning: { 
        name: 'Chrome Lightning', 
        color: '#00FFFF', 
        icon: 'âš¡',
        boost: 3
    },
    blueSuedeShield: { 
        name: 'Blue Suede Shield', 
        color: '#4169E1', 
        icon: 'ðŸ›¡ï¸',
        duration: 5
    },
    duckTailDraft: { 
        name: 'Duck Tail Draft', 
        color: '#FFD700', 
        icon: 'ðŸ’¨',
        duration: 4
    }
};

// Roadside objects
const ROADSIDE_OBJECTS = {
    palmTree: { width: 80, height: 200, color: '#228B22' },
    diner: { width: 300, height: 150, color: '#FF69B4' },
    billboard: { width: 150, height: 100, color: '#FFD700' },
    cactus: { width: 60, height: 100, color: '#2F4F2F' },
    gasStation: { width: 200, height: 120, color: '#DC143C' }
};

// Initialize track with curves and hills
function initTrack() {
    console.log('Initializing track with', trackLength, 'segments');
    for (let i = 0; i < trackLength; i++) {
        const segment = {
            index: i,
            curve: 0,
            y: 0,
            color: i % 2 === 0 ? '#404040' : '#383838',
            sideColor: i % 2 === 0 ? '#ff0000' : '#ffffff',
            roadside: [],
            isFinishLine: i === 0,  // First segment is start/finish
            checkpoint: i === Math.floor(trackLength / 2)  // Checkpoint at halfway
        };
        
        // Create varied track sections
        if (i > 20 && i < 40) {
            // S-curve section
            segment.curve = Math.sin(i * 0.1) * 5;
        } else if (i > 60 && i < 80) {
            // Sharp right turn
            segment.curve = 4;
        } else if (i > 100 && i < 120) {
            // Sharp left turn
            segment.curve = -4;
        } else if (i > 140 && i < 180) {
            // Winding section
            segment.curve = Math.sin(i * 0.08) * 3 + Math.cos(i * 0.05) * 2;
        }
        
        // Hills
        segment.y = Math.sin(i * 0.04) * 150 + Math.cos(i * 0.07) * 80;
        
        // Add roadside objects
        if (i % 10 === 0) {
            // Left side object
            const leftObj = ['palmTree', 'cactus', 'billboard'][Math.floor(Math.random() * 3)];
            segment.roadside.push({
                type: leftObj,
                x: -trackWidth * 0.8,
                sprite: ROADSIDE_OBJECTS[leftObj]
            });
            
            // Right side object
            const rightObj = ['palmTree', 'diner', 'gasStation'][Math.floor(Math.random() * 3)];
            segment.roadside.push({
                type: rightObj,
                x: trackWidth * 0.8,
                sprite: ROADSIDE_OBJECTS[rightObj]
            });
        }
        
        segments.push(segment);
    }
    console.log('Track initialized with', segments.length, 'segments');
    
    // Initialize power-ups on track
    initPowerUps();
}

// Initialize power-ups
function initPowerUps() {
    powerUps.length = 0; // Clear existing
    
    // Place power-ups at regular intervals
    for (let i = 0; i < 20; i++) {
        const segmentIndex = (i * 10 + 5) % trackLength;
        const types = Object.keys(POWERUP_TYPES);
        const type = types[Math.floor(Math.random() * types.length)];
        
        powerUps.push({
            type: type,
            segmentIndex: segmentIndex,
            x: (Math.random() - 0.5) * trackWidth * 0.6,
            collected: false,
            respawnTimer: 0
        });
    }
}

// Project 3D coordinates to 2D screen
function project(worldX, worldY, worldZ, cameraX, cameraY, cameraZ) {
    const scale = 300 / Math.max(1, worldZ - cameraZ);
    const screenX = (worldX - cameraX) * scale + canvas.width / 2;
    const screenY = canvas.height / 2 - (worldY - cameraY) * scale;
    const w = Math.max(1, scale * trackWidth);
    return { x: screenX, y: screenY, w: w, scale: scale };
}

// Start game
function startGame() {
    document.getElementById('startScreen').style.display = 'none';
    game.state = 'racing';
    initTrack();
    initOpponents();
    gameLoop();
}

// Update game logic
function update(dt) {
    if (game.state !== 'racing') return;
    
    // Handle countdown
    if (!game.raceStarted) {
        game.countdown -= dt;
        if (game.countdown <= 0) {
            game.raceStarted = true;
        }
        return; // Don't update physics during countdown
    }
    
    // Handle acceleration
    if (keys['ArrowUp'] && !player.finished) {
        player.speed += player.acceleration + player.boostPower * 5;
        if (player.speed > player.maxSpeed + player.boostPower * 200) {
            player.speed = player.maxSpeed + player.boostPower * 200;
        }
    } else {
        player.speed -= player.acceleration * 2;
        if (player.speed < 0) player.speed = 0;
    }
    
    // Handle steering with drift mechanics
    const turnSpeed = 4 * (player.speed / player.maxSpeed);
    const wasDrifting = player.drifting;
    
    if (keys['ArrowLeft'] && player.speed > 50) {
        player.steering = Math.max(player.steering - 0.08, -0.5);
        player.lateralVelocity -= turnSpeed;
    } else if (keys['ArrowRight'] && player.speed > 50) {
        player.steering = Math.min(player.steering + 0.08, 0.5);
        player.lateralVelocity += turnSpeed;
    } else {
        player.steering *= 0.85;
    }
    
    // Drift mechanics
    player.drifting = keys[' '] && player.speed > player.maxSpeed * 0.4 && Math.abs(player.steering) > 0.1;
    
    if (player.drifting) {
        // Increase drift angle and power while drifting
        player.driftAngle = player.steering * 1.5;
        player.driftPower = Math.min(player.driftPower + dt * 2, 3);
        player.lateralVelocity += player.driftAngle * turnSpeed * 0.7;
        
        // Add some opposite lock for realism
        if (Math.abs(player.lateralVelocity) > 5) {
            player.lateralVelocity *= 0.95;
        }
    } else {
        // Release drift boost when stopping drift
        if (wasDrifting && player.driftPower > 1) {
            player.boostPower = player.driftPower * 0.5;
        }
        player.driftAngle *= 0.9;
        player.driftPower = Math.max(player.driftPower - dt * 4, 0);
    }
    
    // Apply boost decay
    player.boostPower = Math.max(player.boostPower - dt * 2, 0);
    
    // Apply lateral movement with grip
    if (!player.drifting) {
        player.x += player.lateralVelocity;
        player.lateralVelocity *= 0.85; // Grip when not drifting
    } else {
        player.x += player.lateralVelocity * 1.2; // Slide more when drifting
        player.lateralVelocity *= 0.92;
    }
    
    // Update position
    player.position += (player.speed + player.boostPower * 200) * dt;
    
    // Track boundaries with smooth collision
    const limit = 900;
    if (player.x < -limit || player.x > limit) {
        player.x = Math.max(-limit, Math.min(limit, player.x));
        player.lateralVelocity *= -0.5; // Bounce off walls
        player.speed *= 0.8; // Slow down on wall hit
    }
    
    // Check for checkpoint and lap completion
    const currentSegmentIndex = Math.floor(player.position / segmentLength) % trackLength;
    const currentSegment = segments[currentSegmentIndex];
    
    // Checkpoint tracking
    if (currentSegment && currentSegment.checkpoint && player.checkpoint === 0) {
        player.checkpoint = 1;
    }
    
    // Lap completion
    if (currentSegment && currentSegment.isFinishLine && player.checkpoint === 1) {
        player.lap++;
        player.checkpoint = 0;
        
        // Check for race completion
        if (player.lap >= game.totalLaps && !player.finished) {
            player.finished = true;
            player.finishTime = game.frame / 60; // Time in seconds
            game.finishOrder.push({ name: 'You', time: player.finishTime });
        }
    }
    
    // Loop track position (but keep counting total distance)
    while (player.position >= trackLength * segmentLength) {
        player.position -= trackLength * segmentLength;
    }
    
    // Update power-ups
    updatePowerUps(dt);
    
    // Handle power-up input
    if (keys['Enter'] && player.powerUp && !player.powerUpActive) {
        activatePowerUp(player);
    }
    
    // Update active power-ups
    updateActivePowerUps(dt);
    
    // Update AI opponents
    updateOpponents(dt);
    
    // Check collisions
    checkCollisions();
    
    // Check if race is finished
    if (game.finishOrder.length === 5) {
        game.raceFinished = true;
    }
    
    game.frame++;
}

// Power-up collision and updates
function updatePowerUps(dt) {
    powerUps.forEach(powerUp => {
        // Respawn timer
        if (powerUp.collected && powerUp.respawnTimer > 0) {
            powerUp.respawnTimer -= dt;
            if (powerUp.respawnTimer <= 0) {
                powerUp.collected = false;
            }
        }
        
        // Check collision with player
        if (!powerUp.collected && !player.powerUp) {
            const powerUpPos = powerUp.segmentIndex * segmentLength;
            const distance = Math.abs(player.position - powerUpPos);
            const xDistance = Math.abs(player.x - powerUp.x);
            
            if (distance < 100 && xDistance < 150) {
                powerUp.collected = true;
                powerUp.respawnTimer = 10; // 10 seconds to respawn
                player.powerUp = powerUp.type;
            }
        }
    });
}

// Activate power-up
function activatePowerUp(kart) {
    const type = kart.powerUp;
    const powerUpData = POWERUP_TYPES[type];
    
    switch(type) {
        case 'chromeLightning':
            kart.boostPower = powerUpData.boost;
            break;
            
        case 'blueSuedeShield':
            kart.shielded = true;
            kart.powerUpTimer = powerUpData.duration;
            kart.powerUpActive = type;
            break;
            
        case 'duckTailDraft':
            kart.maxSpeed *= 1.3;
            kart.powerUpTimer = powerUpData.duration;
            kart.powerUpActive = type;
            break;
            
        case 'pomadeSlick':
            // Drop oil slick behind
            // For now, just affect nearby opponents
            opponents.forEach(opp => {
                if (Math.abs(opp.position - kart.position) < 500) {
                    opp.slipping = true;
                    opp.lateralVelocity += (Math.random() - 0.5) * 20;
                }
            });
            break;
            
        case 'jukeboxBlast':
            // Blast nearby opponents
            opponents.forEach(opp => {
                const dist = Math.abs(opp.position - kart.position);
                if (dist < powerUpData.radius) {
                    opp.speed *= 0.5;
                    opp.lateralVelocity += (Math.random() - 0.5) * 30;
                }
            });
            break;
    }
    
    kart.powerUp = null; // Consume power-up
}

// Update active power-ups
function updateActivePowerUps(dt) {
    // Player power-ups
    if (player.powerUpActive) {
        player.powerUpTimer -= dt;
        if (player.powerUpTimer <= 0) {
            // Deactivate power-up
            if (player.powerUpActive === 'blueSuedeShield') {
                player.shielded = false;
            } else if (player.powerUpActive === 'duckTailDraft') {
                player.maxSpeed /= 1.3;
            }
            player.powerUpActive = null;
        }
    }
    
    // Clear slipping effect
    if (player.slipping) {
        player.lateralVelocity *= 0.9;
        if (Math.abs(player.lateralVelocity) < 1) {
            player.slipping = false;
        }
    }
    
    // Update collision timer
    if (player.collisionTimer > 0) {
        player.collisionTimer -= dt;
    }
}

// Collision detection between karts
function checkCollisions() {
    const collisionDistance = 200; // Distance threshold for collision
    const collisionWidth = 150; // Width threshold
    
    // Check player vs opponents
    opponents.forEach(opp => {
        const distZ = Math.abs(player.position - opp.position);
        const distX = Math.abs(player.x - opp.x);
        
        if (distZ < collisionDistance && distX < collisionWidth) {
            // Collision detected!
            handleCollision(player, opp);
        }
    });
    
    // Check opponent vs opponent
    for (let i = 0; i < opponents.length; i++) {
        for (let j = i + 1; j < opponents.length; j++) {
            const opp1 = opponents[i];
            const opp2 = opponents[j];
            
            const distZ = Math.abs(opp1.position - opp2.position);
            const distX = Math.abs(opp1.x - opp2.x);
            
            if (distZ < collisionDistance && distX < collisionWidth) {
                handleCollision(opp1, opp2);
            }
        }
    }
}

// Handle collision between two karts
function handleCollision(kart1, kart2) {
    // Skip if either kart is shielded
    if (kart1.shielded || kart2.shielded) {
        // Bouncy shield effect
        if (kart1.shielded && !kart2.shielded) {
            kart2.speed *= 0.5;
            kart2.lateralVelocity += (kart2.x - kart1.x) * 0.5;
        } else if (kart2.shielded && !kart1.shielded) {
            kart1.speed *= 0.5;
            kart1.lateralVelocity += (kart1.x - kart2.x) * 0.5;
        }
        return;
    }
    
    // Calculate collision physics
    const speedDiff = kart1.speed - kart2.speed;
    const xDiff = kart1.x - kart2.x;
    
    // Transfer momentum
    const impactForce = Math.abs(speedDiff) * 0.1;
    
    // Apply collision effects
    if (speedDiff > 0) {
        // Kart1 hitting kart2 from behind
        kart1.speed *= 0.8;
        kart2.speed = Math.min(kart2.speed + impactForce * 20, kart2.maxSpeed);
        
        // Lateral push
        kart1.lateralVelocity -= xDiff * 0.1;
        kart2.lateralVelocity += xDiff * 0.2;
    } else {
        // Kart2 hitting kart1 from behind
        kart2.speed *= 0.8;
        kart1.speed = Math.min(kart1.speed + impactForce * 20, kart1.maxSpeed);
        
        // Lateral push
        kart2.lateralVelocity += xDiff * 0.1;
        kart1.lateralVelocity -= xDiff * 0.2;
    }
    
    // Add some randomness for more dynamic collisions
    kart1.lateralVelocity += (Math.random() - 0.5) * 5;
    kart2.lateralVelocity += (Math.random() - 0.5) * 5;
    
    // Set collision timer for visual feedback
    kart1.collisionTimer = 0.5;
    kart2.collisionTimer = 0.5;
    
    // Separate karts to prevent overlap
    const separation = collisionWidth - Math.abs(xDiff);
    if (separation > 0) {
        if (xDiff > 0) {
            kart1.x += separation / 2;
            kart2.x -= separation / 2;
        } else {
            kart1.x -= separation / 2;
            kart2.x += separation / 2;
        }
    }
}

// AI opponent logic
function updateOpponents(dt) {
    opponents.forEach((opp, index) => {
        // Get track segment info for AI
        const oppSegmentIndex = Math.floor(opp.position / segmentLength) % trackLength;
        const oppSegment = segments[oppSegmentIndex] || segments[0];
        const nextSegmentIndex = (oppSegmentIndex + 5) % trackLength;  // Look ahead
        const nextSegment = segments[nextSegmentIndex] || segments[0];
        
        // Don't move if finished
        if (opp.finished) {
            opp.speed = 0;
            return;
        }
        
        // AI acceleration - rubber band effect
        const distanceToPlayer = player.position + (player.lap * trackLength * segmentLength) 
                               - (opp.position + (opp.lap * trackLength * segmentLength));
        const rubberBand = distanceToPlayer > 2000 ? 1.3 : (distanceToPlayer < -2000 ? 0.8 : 1);
        
        opp.speed += 20 * rubberBand;
        if (opp.speed > opp.maxSpeed * rubberBand) {
            opp.speed = opp.maxSpeed * rubberBand;
        }
        
        // AI steering - follow racing line with personality
        const racingLine = -oppSegment.curve * 100 - nextSegment.curve * 50;
        opp.targetX = racingLine + (Math.sin(opp.position * 0.01 + index) * 200 * opp.personality);
        
        // Smooth steering
        const steerDirection = Math.sign(opp.targetX - opp.x);
        opp.steering = steerDirection * 0.3;
        
        // Apply lateral velocity from collisions
        opp.x += (opp.targetX - opp.x) * 0.1 + opp.lateralVelocity * dt;
        opp.lateralVelocity *= 0.9; // Friction
        
        // Random boost for more dynamic racing
        if (Math.random() < 0.01 && oppSegment.curve < 1) {
            opp.boostPower = 2;
        }
        opp.boostPower = Math.max(0, opp.boostPower - dt * 2);
        
        // Update position
        opp.position += (opp.speed + opp.boostPower * 100) * dt;
        
        // Keep on track
        opp.x = Math.max(-800, Math.min(800, opp.x));
        
        // Update collision timer
        if (opp.collisionTimer > 0) {
            opp.collisionTimer -= dt;
        }
        
        // Check for checkpoint and lap completion
        if (oppSegment.checkpoint && opp.checkpoint === 0) {
            opp.checkpoint = 1;
        }
        
        if (oppSegment.isFinishLine && opp.checkpoint === 1) {
            opp.lap++;
            opp.checkpoint = 0;
            
            // Check for race completion
            if (opp.lap >= game.totalLaps && !opp.finished) {
                opp.finished = true;
                opp.finishTime = game.frame / 60;
                game.finishOrder.push({ name: opp.name, time: opp.finishTime });
            }
        }
        
        // Loop track
        while (opp.position >= trackLength * segmentLength) {
            opp.position -= trackLength * segmentLength;
        }
    });
}

// Render everything
function render() {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Sky gradient with time of day effect
    const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height / 2);
    const timeOfDay = (game.frame * 0.001) % 1; // Slow day/night cycle
    
    if (timeOfDay < 0.3) {
        // Dawn
        skyGradient.addColorStop(0, '#FF6B6B');
        skyGradient.addColorStop(0.5, '#FFE66D');
        skyGradient.addColorStop(1, '#87CEEB');
    } else if (timeOfDay < 0.7) {
        // Day
        skyGradient.addColorStop(0, '#87CEEB');
        skyGradient.addColorStop(1, '#98D8E8');
    } else {
        // Dusk
        skyGradient.addColorStop(0, '#4A5C6A');
        skyGradient.addColorStop(0.5, '#FF6B6B');
        skyGradient.addColorStop(1, '#FFB6C1');
    }
    
    ctx.fillStyle = skyGradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Sun/Moon
    const celestialY = 80;
    const celestialX = canvas.width * 0.8;
    ctx.fillStyle = timeOfDay < 0.7 ? '#FFD700' : '#F0E68C';
    ctx.beginPath();
    ctx.arc(celestialX, celestialY, 40, 0, Math.PI * 2);
    ctx.fill();
    
    // Clouds
    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
    for (let i = 0; i < 5; i++) {
        const cloudX = (i * 200 + game.frame * 0.1) % (canvas.width + 100) - 50;
        const cloudY = 50 + i * 30;
        
        // Simple cloud shape
        ctx.beginPath();
        ctx.arc(cloudX, cloudY, 30, 0, Math.PI * 2);
        ctx.arc(cloudX + 25, cloudY, 35, 0, Math.PI * 2);
        ctx.arc(cloudX + 50, cloudY, 30, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Draw distant mountains
    ctx.fillStyle = '#4A5C6A';
    ctx.beginPath();
    ctx.moveTo(0, canvas.height / 2);
    for (let x = 0; x <= canvas.width; x += 50) {
        const mountainHeight = Math.sin(x * 0.01) * 50 + Math.cos(x * 0.02) * 30 + canvas.height / 2 - 100;
        ctx.lineTo(x, mountainHeight);
    }
    ctx.lineTo(canvas.width, canvas.height / 2);
    ctx.closePath();
    ctx.fill();
    
    // Calculate camera position
    const baseSegment = Math.floor(player.position / segmentLength);
    const currentSegment = segments[baseSegment % trackLength] || segments[0];
    const cameraHeight = currentSegment.y + 300;
    const cameraZ = player.position;
    
    // Draw track segments from back to front
    const drawDistance = 50;  // Increased draw distance for high speed
    
    for (let n = drawDistance; n > 0; n--) {
        const segmentIndex = (baseSegment + n) % trackLength;
        const segment = segments[segmentIndex];
        
        // Calculate segment position
        const segmentZ = (baseSegment + n) * segmentLength;
        
        // Get current and next segment projections
        const p1 = project(
            -trackWidth / 2 + segment.curve * 100,
            segment.y,
            segmentZ,
            player.x,
            cameraHeight,
            cameraZ
        );
        
        const p2 = project(
            trackWidth / 2 + segment.curve * 100,
            segment.y,
            segmentZ,
            player.x,
            cameraHeight,
            cameraZ
        );
        
        // Only draw if segment is visible and in front of camera
        if (p1.w > 0 && p1.scale > 0 && p1.y > 0 && p1.y < canvas.height) {
            // Draw grass with gradient
            const grassGradient = ctx.createLinearGradient(0, p1.y, 0, canvas.height);
            const grassColor1 = n % 2 ? '#2d5a1e' : '#2d6a1e';
            const grassColor2 = n % 2 ? '#1d4a0e' : '#1d5a0e';
            grassGradient.addColorStop(0, grassColor1);
            grassGradient.addColorStop(1, grassColor2);
            ctx.fillStyle = grassGradient;
            ctx.fillRect(0, p1.y, canvas.width, canvas.height - p1.y);
            
            // Draw road with better shading
            const roadGradient = ctx.createLinearGradient(p1.x, 0, p2.x, 0);
            roadGradient.addColorStop(0, '#303030');
            roadGradient.addColorStop(0.5, segment.color);
            roadGradient.addColorStop(1, '#303030');
            ctx.fillStyle = roadGradient;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            
            if (n > 1) {
                const prevSegmentIndex = (baseSegment + n - 1) % trackLength;
                const prevSegment = segments[prevSegmentIndex];
                const prevZ = (baseSegment + n - 1) * segmentLength;
                
                const p3 = project(
                    trackWidth / 2 + prevSegment.curve * 100,
                    prevSegment.y,
                    prevZ,
                    player.x,
                    cameraHeight,
                    cameraZ
                );
                
                const p4 = project(
                    -trackWidth / 2 + prevSegment.curve * 100,
                    prevSegment.y,
                    prevZ,
                    player.x,
                    cameraHeight,
                    cameraZ
                );
                
                ctx.lineTo(p3.x, p3.y);
                ctx.lineTo(p4.x, p4.y);
            }
            
            ctx.closePath();
            ctx.fill();
            
            // Draw start/finish line
            if (segment.isFinishLine && p1.scale > 0.5) {
                // Checkered pattern
                const checkerSize = 40 * p1.scale;
                const numCheckers = Math.floor(p1.w / checkerSize);
                
                for (let c = 0; c < numCheckers; c++) {
                    ctx.fillStyle = (c % 2) ? '#000' : '#FFF';
                    ctx.fillRect(p1.x + c * checkerSize, p1.y - 10, checkerSize, 20);
                }
                
                // "START/FINISH" text
                if (p1.scale > 2) {
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 48px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('START/FINISH', canvas.width / 2, p1.y - 50);
                }
            }
            
            // Draw rumble strips
            if (n % 2) {
                ctx.strokeStyle = segment.sideColor;
                ctx.lineWidth = p1.w * 0.05;
                ctx.beginPath();
                ctx.moveTo(p1.x - p1.w * 0.05, p1.y);
                ctx.lineTo(p2.x + p2.w * 0.05, p2.y);
                ctx.stroke();
            }
            
            // Draw center line
            if (n % 4 < 2) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 10]);
                ctx.beginPath();
                ctx.moveTo((p1.x + p2.x) / 2, p1.y);
                if (n > 1) {
                    const prevSegmentIndex = (baseSegment + n - 1) % trackLength;
                    const prevSegment = segments[prevSegmentIndex];
                    const prevZ = (baseSegment + n - 1) * segmentLength;
                    
                    const p3 = project(
                        prevSegment.curve * 100,
                        prevSegment.y,
                        prevZ,
                        player.x,
                        cameraHeight,
                        cameraZ
                    );
                    ctx.lineTo(p3.x, p3.y);
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Draw roadside objects
            if (segment.roadside && p1.scale > 0.4 && p1.scale < 15) {
                segment.roadside.forEach(obj => {
                    const objX = p1.x + (obj.x - player.x) * p1.scale;
                    const objY = p1.y;
                    const objW = obj.sprite.width * p1.scale;
                    const objH = obj.sprite.height * p1.scale;
                    
                    // Simple object rendering
                    ctx.fillStyle = obj.sprite.color;
                    
                    switch(obj.type) {
                        case 'palmTree':
                            // Trunk
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(objX - objW/6, objY - objH, objW/3, objH);
                            // Leaves
                            ctx.fillStyle = '#228B22';
                            ctx.beginPath();
                            ctx.arc(objX, objY - objH, objW/2, 0, Math.PI * 2);
                            ctx.fill();
                            break;
                            
                        case 'cactus':
                            ctx.fillStyle = '#2F4F2F';
                            ctx.fillRect(objX - objW/2, objY - objH, objW, objH);
                            // Arms
                            ctx.fillRect(objX - objW, objY - objH/2, objW/3, objH/3);
                            ctx.fillRect(objX + objW*0.7, objY - objH*0.7, objW/3, objH/3);
                            break;
                            
                        case 'billboard':
                            // Post
                            ctx.fillStyle = '#654321';
                            ctx.fillRect(objX - 5, objY - objH, 10, objH);
                            // Sign
                            ctx.fillStyle = '#FFD700';
                            ctx.fillRect(objX - objW/2, objY - objH, objW, objH/2);
                            // Text
                            ctx.fillStyle = '#000';
                            ctx.font = Math.floor(objH/8) + 'px Arial';
                            ctx.fillText('ELVIS', objX - objW/3, objY - objH*0.7);
                            break;
                            
                        case 'diner':
                            // Building
                            ctx.fillStyle = '#FF69B4';
                            ctx.fillRect(objX - objW/2, objY - objH, objW, objH);
                            // Roof
                            ctx.fillStyle = '#8B0000';
                            ctx.beginPath();
                            ctx.moveTo(objX - objW/2 - 20, objY - objH);
                            ctx.lineTo(objX + objW/2 + 20, objY - objH);
                            ctx.lineTo(objX, objY - objH - 40);
                            ctx.closePath();
                            ctx.fill();
                            // Sign
                            ctx.fillStyle = '#FFF';
                            ctx.font = Math.floor(objH/6) + 'px Arial';
                            ctx.fillText('DINER', objX - objW/4, objY - objH/2);
                            break;
                            
                        case 'gasStation':
                            // Canopy
                            ctx.fillStyle = '#DC143C';
                            ctx.fillRect(objX - objW/2, objY - objH, objW, 20);
                            // Pumps
                            ctx.fillStyle = '#B22222';
                            ctx.fillRect(objX - objW/3, objY - objH + 20, 30, objH - 20);
                            ctx.fillRect(objX + objW/4, objY - objH + 20, 30, objH - 20);
                            break;
                    }
                });
            }
        }
    }
    
    // Draw power-ups
    powerUps.forEach(powerUp => {
        if (powerUp.collected) return;
        
        const segmentZ = powerUp.segmentIndex * segmentLength;
        const powerUpZ = segmentZ - player.position;
        
        // Only draw if visible
        if (powerUpZ > -200 && powerUpZ < drawDistance * segmentLength) {
            const segment = segments[powerUp.segmentIndex];
            if (!segment) return;
            
            const projected = project(
                powerUp.x,
                segment.y - 50, // Float above track
                segmentZ,
                player.x,
                cameraHeight,
                cameraZ
            );
            
            if (projected.scale > 0.2 && projected.scale < 5) {
                const size = 60 * projected.scale;
                const powerUpData = POWERUP_TYPES[powerUp.type];
                
                // Glowing effect
                ctx.save();
                ctx.translate(projected.x, projected.y);
                
                // Outer glow
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
                gradient.addColorStop(0, powerUpData.color);
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(-size, -size, size * 2, size * 2);
                
                // Power-up box
                ctx.fillStyle = powerUpData.color;
                ctx.fillRect(-size/2, -size/2, size, size);
                
                // Icon
                ctx.fillStyle = '#FFF';
                ctx.font = Math.floor(size * 0.8) + 'px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(powerUpData.icon, 0, 0);
                
                ctx.restore();
            }
        }
    });
    
    // Draw AI opponents
    opponents.forEach((opp, index) => {
        // Calculate opponent screen position
        const oppZ = opp.position - player.position;
        
        // Only draw if opponent is visible
        if (oppZ > -500 && oppZ < drawDistance * segmentLength) {
            const oppSegmentIndex = Math.floor(opp.position / segmentLength) % trackLength;
            const oppSegment = segments[oppSegmentIndex] || segments[0];
            
            const oppProjected = project(
                opp.x,
                oppSegment.y,
                opp.position,
                player.x,
                cameraHeight,
                cameraZ
            );
            
            if (oppProjected.scale > 0.1 && oppProjected.scale < 10 && oppProjected.y < canvas.height - 50) {
                const oppKartSize = 80 * oppProjected.scale;
                
                ctx.save();
                ctx.translate(oppProjected.x, oppProjected.y);
                ctx.rotate(opp.steering * 0.3);
                
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(0, oppKartSize * 0.4, oppKartSize * 0.6, oppKartSize * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Collision flash effect
                if (opp.collisionTimer && opp.collisionTimer > 0) {
                    ctx.fillStyle = '#FFF';
                    ctx.globalAlpha = opp.collisionTimer * 2;
                    ctx.fillRect(-oppKartSize / 2 - 10, -oppKartSize / 2 - 10, 
                                oppKartSize + 20, oppKartSize * 0.7 + 20);
                    ctx.globalAlpha = 1;
                }
                
                // AI kart body
                ctx.fillStyle = opp.color;
                ctx.fillRect(-oppKartSize / 2, -oppKartSize / 2, oppKartSize, oppKartSize * 0.7);
                
                // Number
                ctx.fillStyle = '#FFF';
                ctx.font = Math.floor(oppKartSize * 0.4) + 'px Arial';
                ctx.textAlign = 'center';
                ctx.fillText((index + 2).toString(), 0, -oppKartSize * 0.1);
                
                // Windshield
                ctx.fillStyle = 'rgba(65, 105, 225, 0.7)';
                ctx.fillRect(-oppKartSize / 3, -oppKartSize / 3, oppKartSize * 0.66, oppKartSize * 0.3);
                
                // Name tag above kart
                ctx.fillStyle = '#FFF';
                ctx.font = '14px Arial';
                ctx.fillText(opp.name, 0, -oppKartSize);
                
                ctx.restore();
            }
        }
    });
    
    // Draw player kart
    const kartSize = 80;
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height - 100);
    ctx.rotate(player.steering * 0.5 + player.driftAngle * 0.3);
    
    // Enhanced drift smoke
    if (player.drifting || player.driftPower > 0.5) {
        const smokeIntensity = player.drifting ? 0.5 : 0.3;
        ctx.globalAlpha = smokeIntensity * (player.driftPower / 3);
        
        // Multiple smoke clouds
        for (let i = 0; i < 5; i++) {
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            const offsetX = -40 + Math.random() * 80;
            const offsetY = 30 + Math.random() * 30;
            const size = 15 + Math.random() * 25 + player.driftPower * 5;
            ctx.arc(offsetX, offsetY, size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Tire marks effect
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = '#000000';
        ctx.fillRect(-kartSize/2 - 10, kartSize/4, 20, 40);
        ctx.fillRect(kartSize/2 - 10, kartSize/4, 20, 40);
        
        ctx.globalAlpha = 1;
    }
    
    // Boost flames
    if (player.boostPower > 0) {
        ctx.save();
        ctx.globalAlpha = player.boostPower / 3;
        
        // Exhaust flames
        const flameColors = ['#FFD700', '#FF6347', '#FF1493'];
        for (let i = 0; i < 3; i++) {
            ctx.fillStyle = flameColors[i];
            ctx.beginPath();
            const flameSize = 20 + i * 10;
            const flameOffset = kartSize/2 + i * 15;
            ctx.moveTo(-20, flameOffset);
            ctx.lineTo(20, flameOffset);
            ctx.lineTo(0, flameOffset + flameSize + Math.random() * 10);
            ctx.closePath();
            ctx.fill();
        }
        ctx.restore();
    }
    
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(0, kartSize * 0.4, kartSize * 0.6, kartSize * 0.2, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Collision flash effect
    if (player.collisionTimer > 0) {
        ctx.fillStyle = '#FFF';
        ctx.globalAlpha = player.collisionTimer * 2;
        ctx.fillRect(-kartSize / 2 - 10, -kartSize / 2 - 10, 
                    kartSize + 20, kartSize * 0.7 + 20);
        ctx.globalAlpha = 1;
    }
    
    // Kart body
    ctx.fillStyle = '#ff1493';
    ctx.fillRect(-kartSize / 2, -kartSize / 2, kartSize, kartSize * 0.7);
    
    // Windshield
    ctx.fillStyle = '#4169E1';
    ctx.fillRect(-kartSize / 3, -kartSize / 3, kartSize * 0.66, kartSize * 0.3);
    
    // Wheels
    ctx.fillStyle = '#000';
    ctx.fillRect(-kartSize / 2 - 10, -kartSize / 2 + 5, 20, 30);
    ctx.fillRect(kartSize / 2 - 10, -kartSize / 2 + 5, 20, 30);
    ctx.fillRect(-kartSize / 2 - 10, kartSize / 4, 20, 30);
    ctx.fillRect(kartSize / 2 - 10, kartSize / 4, 20, 30);
    
    ctx.restore();
    
    // Draw HUD
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 48px Courier New';
    ctx.fillText(Math.floor(player.speed) + ' MPH', 50, 80);
    
    // Lap counter
    ctx.font = 'bold 36px Courier New';
    ctx.fillStyle = '#FFD700';
    ctx.fillText(`LAP ${Math.min(player.lap + 1, game.totalLaps)}/${game.totalLaps}`, 50, 130);
    
    // Power-up display
    if (player.powerUp) {
        const powerUpData = POWERUP_TYPES[player.powerUp];
        ctx.fillStyle = powerUpData.color;
        ctx.fillRect(50, 160, 150, 80);
        
        ctx.fillStyle = '#000';
        ctx.fillRect(55, 165, 140, 70);
        
        ctx.fillStyle = '#FFF';
        ctx.font = '40px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(powerUpData.icon, 125, 210);
        
        ctx.font = '14px Arial';
        ctx.fillText('ENTER to use', 125, 225);
        ctx.textAlign = 'left';
    }
    
    // Active power-up indicator
    if (player.powerUpActive) {
        const powerUpData = POWERUP_TYPES[player.powerUpActive];
        ctx.fillStyle = powerUpData.color;
        ctx.globalAlpha = 0.3 + Math.sin(game.frame * 0.1) * 0.2;
        ctx.fillRect(0, 0, canvas.width, 10);
        ctx.fillRect(0, canvas.height - 10, canvas.width, 10);
        ctx.globalAlpha = 1;
    }
    
    // Shield effect
    if (player.shielded) {
        ctx.strokeStyle = '#4169E1';
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.5 + Math.sin(game.frame * 0.1) * 0.2;
        ctx.beginPath();
        ctx.arc(canvas.width / 2, canvas.height - 100, 100, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
    }
    
    // Countdown or GO!
    if (!game.raceStarted) {
        ctx.font = 'bold 120px Arial';
        ctx.fillStyle = game.countdown > 1 ? '#FFD700' : '#FF0000';
        ctx.textAlign = 'center';
        ctx.fillText(Math.ceil(game.countdown).toString(), canvas.width / 2, canvas.height / 2);
        ctx.textAlign = 'left';
    } else if (game.frame < 120) { // Show GO! for 2 seconds
        ctx.font = 'bold 120px Arial';
        ctx.fillStyle = '#00FF00';
        ctx.textAlign = 'center';
        ctx.fillText('GO!', canvas.width / 2, canvas.height / 2);
        ctx.textAlign = 'left';
    }
    
    // Race finished overlay
    if (game.raceFinished) {
        // Dark overlay
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Results
        ctx.fillStyle = '#FFD700';
        ctx.font = 'bold 60px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('RACE FINISHED!', canvas.width / 2, 150);
        
        ctx.font = '30px Arial';
        game.finishOrder.forEach((racer, index) => {
            ctx.fillStyle = index === 0 ? '#FFD700' : '#FFF';
            const minutes = Math.floor(racer.time / 60);
            const seconds = (racer.time % 60).toFixed(2);
            ctx.fillText(`${index + 1}. ${racer.name} - ${minutes}:${seconds.padStart(5, '0')}`, 
                        canvas.width / 2, 220 + index * 40);
        });
        ctx.textAlign = 'left';
    }
    
    // Race position indicator
    const racers = [
        { name: 'You', position: player.position + player.lap * trackLength * segmentLength, 
          lap: player.lap, color: '#FF1493' },
        ...opponents.map(opp => ({ 
            name: opp.name, 
            position: opp.position + opp.lap * trackLength * segmentLength,
            lap: opp.lap,
            color: opp.color 
        }))
    ].sort((a, b) => b.position - a.position);
    
    ctx.font = 'bold 20px Courier New';
    ctx.fillStyle = '#FFF';
    ctx.fillText('RACE STANDINGS', canvas.width - 250, 30);
    
    racers.forEach((racer, index) => {
        const isPlayer = racer.name === 'You';
        ctx.font = (isPlayer ? 'bold ' : '') + '18px Courier New';
        ctx.fillStyle = isPlayer ? '#FFD700' : racer.color;
        const lapText = racer.lap >= game.totalLaps ? 'FIN' : `L${racer.lap + 1}`;
        ctx.fillText(`${index + 1}. ${racer.name} ${lapText}`, canvas.width - 250, 60 + index * 25);
    });
    
    // Drift indicator with power meter
    if (player.drifting || player.driftPower > 0) {
        // Drift text
        ctx.fillStyle = '#FFD700';
        ctx.font = 'bold 36px Courier New';
        ctx.fillText('DRIFT!', canvas.width / 2 - 80, 100);
        
        // Drift power meter
        const meterWidth = 200;
        const meterHeight = 20;
        const meterX = canvas.width / 2 - meterWidth / 2;
        const meterY = 120;
        
        // Background
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(meterX, meterY, meterWidth, meterHeight);
        
        // Power fill
        const powerColor = player.driftPower > 2 ? '#FF1493' : '#FFD700';
        ctx.fillStyle = powerColor;
        ctx.fillRect(meterX, meterY, meterWidth * (player.driftPower / 3), meterHeight);
        
        // Border
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.strokeRect(meterX, meterY, meterWidth, meterHeight);
    }
    
    // Boost indicator
    if (player.boostPower > 0) {
        ctx.save();
        ctx.globalAlpha = 0.8;
        ctx.fillStyle = '#00FFFF';
        ctx.font = 'bold 48px Courier New';
        ctx.fillText('BOOST!', canvas.width / 2 - 100, 200);
        
        // Speed lines effect
        ctx.strokeStyle = '#00FFFF';
        ctx.lineWidth = 3;
        ctx.globalAlpha = player.boostPower / 3;
        for (let i = 0; i < 10; i++) {
            ctx.beginPath();
            const y = Math.random() * canvas.height;
            ctx.moveTo(0, y);
            ctx.lineTo(100, y);
            ctx.moveTo(canvas.width - 100, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }
        ctx.restore();
    }
}

// Game loop
let lastTime = 0;
function gameLoop(currentTime) {
    const dt = (currentTime - lastTime) / 1000;
    lastTime = currentTime;
    
    if (dt < 0.1) { // Prevent huge time steps
        update(dt);
    }
    
    render();
    requestAnimationFrame(gameLoop);
}

// Initialize
window.startGame = startGame;